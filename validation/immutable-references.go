package validation

import (
	"encoding/json"
	"fmt"
	"reflect"

	. "github.com/ethereum-optimism/superchain-registry/superchain"
	"github.com/ethereum-optimism/superchain-registry/validation/standard"
)

// ContractASTsWithImmutableReferences caches the `immutableReferences` after parsing it from the config file.
//
//	The config file is generated from the compiled contract AST (from the combined JSON
//
// artifact from the monorepo. We do this because the contracts and compiled artifacts are not available in the superchain
// registry. Ex: ethereum-optimism/optimism/packages/contracts-bedrock/forge-artifacts/MIPS.sol/MIPS.json
var ContractASTsWithImmutableReferences = map[string]string{}

// ImmutableReference to store the start/length of a contract's immutable references. Immutables
// are directly assigned values once or are initialized in a constructor. They are encoded in the contract bytecode,
// and the AST that is generated by the compiler has info about the offset & length within the bytecode.
type ImmutableReference struct {
	Start  int `json:"start"`
	Length int `json:"length"`
}

// Define a struct to represent the structure of the JSON data
type BytecodeAndImmutableReferences struct {
	Bytecode            []byte                          `json:"object"`
	ImmutableReferences map[string][]ImmutableReference `json:"immutableReferences"`
}

// LoadImmutableReferences parses standard-immutables.toml and stores it in a map. Needs to be invoked one-time only.
func LoadImmutableReferences() {
	var bytecodeImmutables *ContractBytecodeImmutables
	for tag := range standard.Versions {
		for contractVersion, immutables := range standard.BytecodeImmutables {
			if tag == contractVersion {
				bytecodeImmutables = &immutables
				break
			}
		}
	}
	if bytecodeImmutables != nil {
		s := reflect.ValueOf(bytecodeImmutables).Elem()
		for i := 0; i < s.NumField(); i++ {
			name := s.Type().Field(i).Name
			value := string(reflect.ValueOf(*bytecodeImmutables).Field(i).String())
			ContractASTsWithImmutableReferences[name] = value
		}
	}
}

// initBytecodeImmutableMask returns the struct with coordinates of the immutable references in the deployed bytecode, if present
func initBytecodeImmutableMask(bytecode []byte, contractName string) (*BytecodeAndImmutableReferences, error) {
	parsedImmutables := map[string][]ImmutableReference{}
	refs, exists := ContractASTsWithImmutableReferences[contractName]
	if exists {
		err := json.Unmarshal([]byte(refs), &parsedImmutables)
		if err != nil {
			return nil, fmt.Errorf("unable to parse immutable references for %s: %w", contractName, err)
		}
	}
	return &BytecodeAndImmutableReferences{Bytecode: bytecode, ImmutableReferences: parsedImmutables}, nil
}

// maskBytecode checks for the presence of immutables in the contract, as indicated by the stored config and if present,
// masks the sections of the bytecode where immutables are stored. If immutables aren't present, the stored bytecode in the receiver is unaltered
func (deployed *BytecodeAndImmutableReferences) maskBytecode(contractName string) error {
	_, exists := ContractASTsWithImmutableReferences[contractName]
	if exists {
		for _, v := range deployed.ImmutableReferences {
			for _, r := range v {
				for i := r.Start; i < r.Start+r.Length; i++ {
					if i >= len(deployed.Bytecode) {
						return fmt.Errorf("immutable reference [start:%d, length: %d] extends beyond bytecode", r.Start, r.Length)
					}
					deployed.Bytecode[i] = 0
				}
			}
		}
	}
	return nil
}
