package validation

import (
	"encoding/json"
	"fmt"
)

// ContractASTsWithImmutableReferences stores the `immutableReferences`, copied from the compiled contract AST (from the combined JSON
// artifact from the monorepo. We do this because the contracts and compiled artifacts are not available in the superchain
// registry. Ex: ethereum-optimism/optimism/packages/contracts-bedrock/forge-artifacts/MIPS.sol/MIPS.json
var ContractASTsWithImmutableReferences = map[string]string{
	"AnchorStateRegistryProxy": `"immutableReferences":{"92829":[{"start":387,"length":32},{"start":828,"length":32},{"start":2296,"length":32}]}`,
	"DelayedWETHProxy":         `"immutableReferences":{"97827":[{"start":831,"length":32},{"start":4133,"length":32}]}`,
	"FaultDisputeGame":         `"immutableReferences":{"92829":[{"start":387,"length":32},{"start":828,"length":32},{"start":2296,"length":32}]}`,
	"MIPS":                     `"immutableReferences":{"85798":[{"start":178,"length":32},{"start":1771,"length":32}]}`,
}

// ImmutableReference to store the start/length of a contract's immutable references. Immutables
// are directly assigned values once or are initialized in a constructor. They are encoded in the contract bytecode,
// and the AST that is generated by the compiler has info about the offset & length within the bytecode.
type ImmutableReference struct {
	Start  int `json:"start"`
	Length int `json:"length"`
}

// Define a struct to represent the structure of the JSON data
type DeployedBytecode struct {
	Bytecode            []byte                          `json:"object"`
	ImmutableReferences map[string][]ImmutableReference `json:"immutableReferences"`
}

// initBytecodeWithImmutables returns coordinates of the immutable references in the deployed bytecode for the given contract
func initBytecodeWithImmutables(bytecode []byte, contractName string) (*DeployedBytecode, error) {
	refs, exists := ContractASTsWithImmutableReferences[contractName]
	if !exists {
		return nil, fmt.Errorf("contract %s does not have immutable references", contractName)
	}
	parsedImmutables := map[string][]ImmutableReference{}
	err := json.Unmarshal([]byte(refs), &parsedImmutables)
	if err != nil {
		return nil, fmt.Errorf("unable to parse immutable references for %s: %w", contractName, err)
	}
	return &DeployedBytecode{Bytecode: bytecode, ImmutableReferences: parsedImmutables}, nil
}

func (deployed *DeployedBytecode) maskBytecode() error {
	for _, v := range deployed.ImmutableReferences {
		for _, r := range v {
			for i := r.Start; i < r.Start+r.Length; i++ {
				if i >= len(deployed.Bytecode) {
					return fmt.Errorf("immutable reference [start:%d, length: %d] extends beyond bytecode", r.Start, r.Length)
				}
				deployed.Bytecode[i] = 0
			}
		}
	}
	return nil
}
