package main

import (
	"encoding/json"
	"fmt"
	"math/big"
	"os"

	"github.com/ethereum-optimism/optimism/op-node/rollup"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/urfave/cli/v2"
)

var CheckRollupConfigCmd = cli.Command{
	Name:  "check-rollup-config",
	Flags: []cli.Flag{ChainIdFlag, RollupConfigFlag},
	Usage: "Sanity check rollup config (rollup.json) is reproducible",
	Action: func(ctx *cli.Context) error {
		// Ensure rollup config generated by op-node right now is equivalent to pre-existing
		// one used to create superchain config files. i.e. compare the following:
		//  1. op-node(superchain/configs/<l1-chain>/<l2-chain>.yaml) --> rollup.Config
		//  2. monorepo/op-node/rollup.json --> rollup.Config
		chainId := ChainIdFlag.Get(ctx)
		rollupConfigPath := RollupConfigFlag.Get(ctx)

		opNodeRollupConfig, err := rollup.LoadOPStackRollupConfig(chainId)
		if err != nil {
			return fmt.Errorf("op-node failed to generate rollup config: %w", err)
		}
		fmt.Printf("Attempting to read from %s\n", rollupConfigPath)
		file, err := os.ReadFile(rollupConfigPath)
		if err != nil {
			return fmt.Errorf("failed to read from local rollup.json config file: %w", err)
		}
		var localRollupConfig *rollup.Config
		if err = json.Unmarshal(file, &localRollupConfig); err != nil {
			return fmt.Errorf("failed to unmarshal local rollup.json into rollup.Config struct: %w", err)
		}

		opts := cmp.Options{
			cmpopts.IgnoreUnexported(big.Int{}),
		}
		if diff := cmp.Diff(localRollupConfig, opNodeRollupConfig, opts...); diff != "" {
			return fmt.Errorf("local rollup.json (-) does not match config generated by op-node (+): %s", diff)
		}

		fmt.Println("Regenerated rollup config matches existing one")
		return nil
	},
}
